Summary of Results / Observations / Insights:
The basic dynamic programming solution optimally populates an n by m matrix with scores representing the cost of alignment for each portion of the string.  By maintaining the entire matrix of scores, we can get the optimal alignment of the input strings.  The optimal alignment minimizes the cost of alignment in our problem.  We retrieve the string alignment for each input string by tracing back through the matrix and observing the path that yields our total cost. At each position in the matrix, we have one of three options to minimize the score: match, vertical gap, and horizontal gap.  The algorithm uses the option that returns the lowest additional cost.  This solution requires O(nm) computational complexity

The efficient version leverages divide and conquer logic to find local alignments of subproblems to minimize memory cost.   The algorithm splits the stings down into smaller subproblems until it gets to its defined base case, then directly solves the subproblems with the same functions developed in the basic dynamic programming solution.  We continuously split on string in half and use dynamic programing to determine the optimal place to split the second string. Because we simply need to determine the optimal place to split the second string, with the appropriate logic, we do not need to keep an n by m matrix but rather just the last column of the matrix.  We observed that the efficient solution requires orders of magnitude less memory than the basic version at a slight tradeoff in computational complexity.  In theory, the computational complexity should be roughly twice the basic implementation of the algorithm.  In practice, each test case required less than twice the computation time than the basic solution.  We learned that the efficient version runs in O(mn) (= O(2mn)) time while using only O(m + n) space, whereas the basic version has a runtime and space requirement of O(mn). The efficient version brings down the space requirement while increasing the running time by at most a constant factor. Throughout this project and within our plots, we observed this to be true. The longer the strings we tested, the more apparent this became. The Memory Usage vs. Problem Size plot reflects how the basic version requires more memory than the efficient version, and the CPU Time vs. Problem Size plot, displays how the efficient version requires greater CPU time than the basic version. 

Contributions:
Completing the project was a collaborative effort. Peter and Luke both contributed to the project and shared the responsibilities related to coding, testing, and report preparation. Luke developed code to read the input.txt file and to implement the basic solution of the sequence alignment problem with contributions and review from Peter.  Peter developed code to generate the string from data in the input file and to implement the memory efficient solution of the sequence alignment problem with contributions, code review and testing by Luke. Both worked together on the code for determining the memory requirements for each solution, creating the plots, and preparing the summary/report.
